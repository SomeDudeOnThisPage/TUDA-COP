package ExerciseLanguage.structure;

/*Generated by MPS */

import jetbrains.mps.lang.smodel.LanguageConceptIndex;
import jetbrains.mps.lang.smodel.LanguageConceptIndexBuilder;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import org.jetbrains.mps.openapi.language.SAbstractConcept;

public final class LanguageConceptSwitch {
  private final LanguageConceptIndex myIndex;
  public static final int BinaryExpression = 0;
  public static final int BinaryOperator = 1;
  public static final int Block = 2;
  public static final int BracketExpression = 3;
  public static final int ClassConcept = 4;
  public static final int ClassFunctionAccessExpression = 5;
  public static final int ClassRegistry = 6;
  public static final int Comment = 7;
  public static final int ConstantBooleanExpression = 8;
  public static final int ConstantIntegerExpression = 9;
  public static final int Continue = 10;
  public static final int DeclarationExpression = 11;
  public static final int Else = 12;
  public static final int EmptyLine = 13;
  public static final int For = 14;
  public static final int FunctionArgument = 15;
  public static final int FunctionDeclaration = 16;
  public static final int FunctionExpression = 17;
  public static final int FunctionParameter = 18;
  public static final int IClassExpression = 19;
  public static final int IControlStatement = 20;
  public static final int IEvaluatable = 21;
  public static final int IExpression = 22;
  public static final int ILoop = 23;
  public static final int IVariableDeclaration = 24;
  public static final int If = 25;
  public static final int If_Else = 26;
  public static final int NullExpression = 27;
  public static final int ObjectInstantiationExpression = 28;
  public static final int Operator = 29;
  public static final int OperatorAdd = 30;
  public static final int OperatorAnd = 31;
  public static final int OperatorAssign = 32;
  public static final int OperatorEquals = 33;
  public static final int OperatorGreaterThan = 34;
  public static final int OperatorLessThan = 35;
  public static final int OperatorMinus = 36;
  public static final int OperatorMultiply = 37;
  public static final int OperatorOr = 38;
  public static final int OperatorUnaryMinus = 39;
  public static final int OperatorUnaryNot = 40;
  public static final int ReferenceExpression = 41;
  public static final int Return = 42;
  public static final int SelfReferenceExpression = 43;
  public static final int UnaryExpression = 44;
  public static final int UnaryOperator = 45;
  public static final int While = 46;

  public LanguageConceptSwitch() {
    LanguageConceptIndexBuilder builder = new LanguageConceptIndexBuilder(0x97a51900650f4519L, 0xa79289e9b2b161cbL);
    builder.put(0x5261d8e675bb66a4L, BinaryExpression);
    builder.put(0x53d99cc795194edeL, BinaryOperator);
    builder.put(0x5261d8e675c22033L, Block);
    builder.put(0x761b7b07134f4fe3L, BracketExpression);
    builder.put(0x39275cb10e6e1429L, ClassConcept);
    builder.put(0x79adcda68aa7076bL, ClassFunctionAccessExpression);
    builder.put(0x1beda7bcefca4f4fL, ClassRegistry);
    builder.put(0x15f528b5f41df886L, Comment);
    builder.put(0x53d99cc795194f20L, ConstantBooleanExpression);
    builder.put(0x5261d8e675bf57e9L, ConstantIntegerExpression);
    builder.put(0x15f528b5f41f46f8L, Continue);
    builder.put(0x7a038777eb3e63d8L, DeclarationExpression);
    builder.put(0x5179ca4b4957f72fL, Else);
    builder.put(0x4c4ecad089585d2aL, EmptyLine);
    builder.put(0x15f528b5f43202c9L, For);
    builder.put(0x39275cb10e726720L, FunctionArgument);
    builder.put(0x304de020ebceefcfL, FunctionDeclaration);
    builder.put(0x304de020ebceefa4L, FunctionExpression);
    builder.put(0x304de020ebcef043L, FunctionParameter);
    builder.put(0x1beda7bcefca4f54L, IClassExpression);
    builder.put(0x79adcda68a9c96a9L, IControlStatement);
    builder.put(0x15f528b5f40aacddL, IEvaluatable);
    builder.put(0x5261d8e675bc9b1cL, IExpression);
    builder.put(0x15f528b5f4308754L, ILoop);
    builder.put(0x4c4ecad0893aec5fL, IVariableDeclaration);
    builder.put(0x5179ca4b4957f720L, If);
    builder.put(0x5179ca4b4957f728L, If_Else);
    builder.put(0x79adcda68a916078L, NullExpression);
    builder.put(0x79adcda68a4cf814L, ObjectInstantiationExpression);
    builder.put(0x5261d8e675bc9b1bL, Operator);
    builder.put(0x5261d8e675bec7b7L, OperatorAdd);
    builder.put(0x5179ca4b495dbea9L, OperatorAnd);
    builder.put(0x5261d8e675c62f7eL, OperatorAssign);
    builder.put(0x5179ca4b495ce63fL, OperatorEquals);
    builder.put(0x5179ca4b495dbe91L, OperatorGreaterThan);
    builder.put(0x5179ca4b495dbe99L, OperatorLessThan);
    builder.put(0x729b0973be7a44efL, OperatorMinus);
    builder.put(0x5261d8e675c90242L, OperatorMultiply);
    builder.put(0x5179ca4b495dbea1L, OperatorOr);
    builder.put(0x729b0973be7ab55dL, OperatorUnaryMinus);
    builder.put(0x33d0f1e7a6eb0f1cL, OperatorUnaryNot);
    builder.put(0x6930950f81a11a81L, ReferenceExpression);
    builder.put(0x15f528b5f42bcef3L, Return);
    builder.put(0x71498cf12ef81aeaL, SelfReferenceExpression);
    builder.put(0x729b0973be7a449fL, UnaryExpression);
    builder.put(0x729b0973be791024L, UnaryOperator);
    builder.put(0x15f528b5f41b7028L, While);
    myIndex = builder.seal();
  }

  /*package*/ int index(SConceptId cid) {
    return myIndex.index(cid);
  }

  public int index(SAbstractConcept concept) {
    return myIndex.index(concept);
  }
}
